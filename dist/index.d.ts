// Generated by dts-bundle v0.7.3

export default class ClusterWS {
    events: EventEmitter;
    options: Options;
    channels: CustomObject;
    useBinary: boolean;
    constructor(configurations: Configurations);
    on(event: 'error', listener: (err: ErrorEvent) => void): void;
    on(event: 'connect', listener: () => void): void;
    on(event: 'disconnect', listener: (code?: number, reason?: string) => void): void;
    on(event: string, listener: Listener): void;
    off(event: string): void;
    getState(): number;
    resetPing(interval?: number): void;
    disconnect(code?: number, reason?: string): void;
    send(event: string, message: Message, eventType?: string): void;
    subscribe(channelName: string): Channel;
    getChannelByName(channelName: string): Channel;
}

export class Channel {
    name: string;
    constructor(socket: ClusterWS, name: string);
    watch(listener: Listener): Channel;
    publish(data: Message): Channel;
    unsubscribe(): void;
    onMessage(data: Message): void;
    subscribe(): void;
}

export class EventEmitter {
    on(event: string, listener: Listener): void;
    off(event: string): void;
    emit(event: string, ...args: any[]): void;
    removeAllEvents(): void;
}

export function decode(socket: ClusterWS, message: Message): void;
export function encode(event: string, data: Message, eventType: string): string;

export function logError<T>(data: T): any;
export function uint8ArrayToString(buffer: any): string;
export function stringToArrayBuffer(str: string): any;

export type Message = any;
export type Listener = (...args: any[]) => void;
export type CustomObject = {
    [propName: string]: any;
};
export type Options = {
    url: string;
    autoReconnect: boolean;
    autoReconnectOptions: {
        attempts: number;
        minInterval: number;
        maxInterval: number;
    };
    encodeDecodeEngine: EncodeDecodeEngine | false;
};
export type Configurations = {
    url: string;
    autoReconnect?: boolean;
    autoReconnectOptions?: {
        attempts?: number;
        minInterval?: number;
        maxInterval?: number;
    };
    encodeDecodeEngine?: EncodeDecodeEngine;
};
export type EncodeDecodeEngine = {
    encode: (message: Message) => Message;
    decode: (message: Message) => Message;
};

